import os
import docx
from docx.shared import Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

# Directories to exclude from processing
EXCLUDED_DIRECTORIES = [
    ".git",
    "venv",
    ".venv",
    "__pycache__",
    "node_modules",
    ".idea",
    ".vscode",
]

# Files to exclude from processing
EXCLUDED_FILES = [
    "setup.py",
    "conftest.py",
    "transpose.py",
]


def is_file_empty_or_init(content, filename):
    """
    Check if a file is empty or just a simple __init__.py

    Args:
        content (str): File content
        filename (str): Name of the file

    Returns:
        bool: True if file should be skipped, False otherwise
    """
    if not content.strip():
        return True

    # Special handling for __init__.py files
    if filename == "__init__.py":
        # Check if file only contains comments, docstrings, or import statements
        stripped_lines = [line.strip() for line in content.split("\n") if line.strip()]
        for line in stripped_lines:
            # If line is not a comment, import statement or docstring starter
            if (
                not line.startswith("#")
                and not line.startswith("import ")
                and not line.startswith("from ")
                and not line.startswith('"""')
                and not line.startswith("'''")
                and '"""' not in line
                and "'''" not in line
            ):
                return False
        return True

    return False


def create_project_documentation(
    project_directory, output_filename="project_documentation.docx", skip_empty=True
):
    """
    Creates a Word document containing the content of all Python files in a project directory.
    Each file's path is added as a header followed by its content in a smaller font size.

    Args:
        project_directory (str): Path to the project directory to scan
        output_filename (str): Name of the output .docx file
        skip_empty (bool): Whether to skip empty files or files with only imports/comments

    Returns:
        str: Path to the created document
    """
    # Ensure project directory exists
    if not os.path.exists(project_directory):
        raise FileNotFoundError(f"Project directory not found: {project_directory}")

    # Get the absolute path of the current script to exclude it
    current_script = os.path.abspath(__file__)

    # Create a new document
    doc = docx.Document()

    # Set default font size
    style = doc.styles["Normal"]
    font = style.font
    font.name = "Calibri"
    font.size = Pt(10)  # Smaller font for code content

    # Add title
    doc.add_heading("Project Documentation", level=1)
    doc.add_paragraph(f"Project Path: {os.path.abspath(project_directory)}")
    doc.add_paragraph("Generated by Python Project Documentation Tool")
    doc.add_paragraph("=" * 80)

    # Process the directory
    file_count = 0
    skipped_files = 0

    for root, dirs, files in os.walk(project_directory):
        # Skip excluded directories - modify dirs in place to prevent os.walk from descending into them
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRECTORIES]

        for file in files:
            # Skip non-Python files and excluded files
            if not file.endswith(".py") or file in EXCLUDED_FILES:
                continue

            file_path = os.path.join(root, file)

            # Skip the script itself - compare absolute paths
            if os.path.abspath(file_path) == current_script:
                continue

            relative_path = os.path.relpath(file_path, project_directory)

            # Read file content
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    content = f.read()

                # Skip empty files or simple __init__.py files if flag is set
                if skip_empty and is_file_empty_or_init(content, file):
                    skipped_files += 1
                    continue

                # Add file path as header
                header = doc.add_heading(relative_path, level=2)
                header.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT

                # Add file content
                paragraph = doc.add_paragraph(content)

                # Add a separator between files
                doc.add_paragraph("=" * 80)
                file_count += 1

            except Exception as e:
                doc.add_paragraph(f"Error reading file {relative_path}: {str(e)}")

    # Add summary at the end
    summary = doc.add_paragraph()
    summary.add_run(f"Total Python files processed: {file_count}").bold = True
    if skipped_files > 0:
        summary.add_run(f"\nSkipped empty or initialization files: {skipped_files}")

    # Make sure output directory exists
    output_dir = os.path.dirname(os.path.join(project_directory, output_filename))
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Save the document
    output_path = os.path.join(project_directory, output_filename)

    try:
        doc.save(output_path)
        print(f"Saving document to: {output_path}")
        return output_path
    except Exception as e:
        print(f"Error saving document: {str(e)}")
        raise


import argparse


def main():
    parser = argparse.ArgumentParser(description="Generate project documentation.")
    parser.add_argument(
        "project_dir",
        nargs="?",
        default=os.getcwd(),
        help="Path to the project directory (default: current directory)",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="project_documentation.docx",
        help="Output .docx file name (default: project_documentation.docx)",
    )
    parser.add_argument(
        "--include-empty",
        action="store_true",
        help="Include empty files and simple __init__.py files",
    )

    args = parser.parse_args()

    output_file = args.output
    # Ensure output file has .docx extension
    if not output_file.endswith(".docx"):
        output_file += ".docx"

    try:
        result_path = create_project_documentation(
            args.project_dir, output_file, skip_empty=not args.include_empty
        )
        print(f"Documentation created successfully at: {result_path}")
        print(f"Full path: {os.path.abspath(result_path)}")
        if not args.include_empty:
            print("Files with no meaningful content were skipped.")
    except Exception as e:
        print(f"Error: {str(e)}")


if __name__ == "__main__":
    main()
