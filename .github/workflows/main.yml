name: CI/CD Pipeline for Windows Server
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-test:
    # Use GitHub-hosted runner for building and testing
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.11
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r server/requirements.txt
      
      - name: Run migrations
        run: |
          cd server
          python manage.py makemigrations
          python manage.py migrate
      
      - name: Run tests
        run: |
          cd server
          python manage.py test
      
      # Build and push Docker image
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      
      - name: Login to Docker Hub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v2
        with:
          context: ./server
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/startup-hub:latest
  
  deploy:
    # Use self-hosted runner only for deployment
    runs-on: self-hosted
    needs: build-and-test
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      # Check if deployment can be performed without waiting
      - name: Check runner readiness
        id: check-runner
        shell: powershell
        run: |
          Write-Host "Runner is ready for deployment"
          echo "::set-output name=ready::true"
        continue-on-error: true
      
      # Deploy using the most appropriate method
      - name: Deploy to Windows server
        if: steps.check-runner.outputs.ready == 'true'
        shell: powershell
        run: |
          # Multiple deployment methods with fallbacks
          $deploymentSuccess = $false
          
          # Method 1: Direct deployment if runner is on target server
          if ($env:COMPUTERNAME -eq "${{ secrets.SERVER_HOSTNAME }}" -or "${{ secrets.SERVER_IP }}" -eq "localhost" -or "${{ secrets.SERVER_IP }}" -eq "127.0.0.1") {
            try {
              Write-Host "Attempting direct deployment (runner is on target server)..."
              docker pull ${{ secrets.DOCKER_USERNAME }}/startup-hub:latest
              docker stop startup-hub 2>$null
              docker rm startup-hub 2>$null
              docker-compose -f C:/app/docker-compose.yaml up -d
              $deploymentSuccess = $true
              Write-Host "✓ Direct deployment successful"
            }
            catch {
              Write-Warning "Direct deployment failed: $_"
            }
          }
          
          # Method 2: Try SSH deployment
          if (-not $deploymentSuccess) {
            try {
              Write-Host "Attempting deployment via SSH..."
              ssh -o "ConnectTimeout=10" -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "powershell -Command {
                Write-Host 'Connected to Windows server'
                docker pull ${{ secrets.DOCKER_USERNAME }}/startup-hub:latest
                docker stop startup-hub 2>$null
                docker rm startup-hub 2>$null
                docker-compose -f C:/app/docker-compose.yaml up -d
              }"
              $deploymentSuccess = $true
              Write-Host "✓ SSH deployment successful"
            }
            catch {
              Write-Warning "SSH deployment failed: $_"
            }
          }
          
          # Method 3: Try PowerShell remoting
          if (-not $deploymentSuccess) {
            try {
              Write-Host "Attempting deployment via PowerShell remoting..."
              $securePassword = ConvertTo-SecureString "${{ secrets.SERVER_PASSWORD }}" -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential ("${{ secrets.SERVER_USER }}", $securePassword)
              
              $session = New-PSSession -ComputerName ${{ secrets.SERVER_IP }} -Credential $cred -ErrorAction Stop
              
              Invoke-Command -Session $session -ScriptBlock {
                Write-Host "Connected via PowerShell remoting"
                docker pull ${{ secrets.DOCKER_USERNAME }}/startup-hub:latest
                docker stop startup-hub 2>$null
                docker rm startup-hub 2>$null
                docker-compose -f C:/app/docker-compose.yaml up -d
              }
              
              Remove-PSSession $session
              $deploymentSuccess = $true
              Write-Host "✓ PowerShell remoting deployment successful"
            }
            catch {
              Write-Error "PowerShell remoting deployment failed: $_"
            }
          }
          
          if (-not $deploymentSuccess) {
            throw "All deployment methods failed. Please check configuration and try again."
          }
      
      # Verification step
      - name: Verify deployment
        if: steps.check-runner.outputs.ready == 'true'
        shell: powershell
        run: |
          $verificationSuccess = $false
          
          # Method 1: Direct verification if on same machine
          if ($env:COMPUTERNAME -eq "${{ secrets.SERVER_HOSTNAME }}" -or "${{ secrets.SERVER_IP }}" -eq "localhost" -or "${{ secrets.SERVER_IP }}" -eq "127.0.0.1") {
            try {
              $containerCheck = docker ps | Select-String 'startup-hub'
              if ($containerCheck) {
                Write-Host "✓ Container is running successfully (verified directly)"
                $verificationSuccess = $true
              }
            }
            catch {
              Write-Warning "Direct verification failed: $_"
            }
          }
          
          # Method 2: SSH verification
          if (-not $verificationSuccess) {
            try {
              $containerCheck = ssh -o "ConnectTimeout=10" -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "docker ps | Select-String 'startup-hub'"
              if ($containerCheck) {
                Write-Host "✓ Container is running successfully (verified via SSH)"
                $verificationSuccess = $true
              }
            }
            catch {
              Write-Warning "SSH verification failed: $_"
            }
          }
          
          # Method 3: PowerShell remoting verification
          if (-not $verificationSuccess) {
            try {
              $securePassword = ConvertTo-SecureString "${{ secrets.SERVER_PASSWORD }}" -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential ("${{ secrets.SERVER_USER }}", $securePassword)
              
              $session = New-PSSession -ComputerName ${{ secrets.SERVER_IP }} -Credential $cred -ErrorAction Stop
              
              $containerCheck = Invoke-Command -Session $session -ScriptBlock {
                docker ps | Select-String 'startup-hub'
              }
              
              Remove-PSSession $session
              
              if ($containerCheck) {
                Write-Host "✓ Container is running successfully (verified via PowerShell remoting)"
                $verificationSuccess = $true
              }
            }
            catch {
              Write-Warning "PowerShell remoting verification failed: $_"
            }
          }
          
          if (-not $verificationSuccess) {
            Write-Warning "Could not verify if container is running. Please check manually."
          }
        continue-on-error: true
      
      # Fallback for when runner isn't ready
      - name: Deployment fallback message
        if: steps.check-runner.outputs.ready != 'true'
        run: |
          echo "Self-hosted runner wasn't ready for deployment. The Docker image was built and pushed successfully."
          echo "You can manually pull and run the image using:"
          echo "docker pull ${{ secrets.DOCKER_USERNAME }}/startup-hub:latest"
          echo "docker-compose -f C:/app/docker-compose.yaml up -d"
  
  notify:
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy]
    if: always()
    steps:
      - name: Notify deployment status
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_TITLE: Deployment Status
          SLACK_MESSAGE: |
            Build & Test: ${{ needs.build-and-test.result }}
            Deploy: ${{ needs.deploy.result }}
            ${{ needs.build-and-test.result == 'success' && needs.deploy.result == 'success' && 'Deployment completed successfully! :rocket:' || 'Deployment encountered issues! :warning:' }}
          SLACK_COLOR: ${{ needs.build-and-test.result == 'success' && needs.deploy.result == 'success' && 'good' || 'danger' }}
        continue-on-error: true
